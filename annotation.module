<?php

function annotation_nodeapi(&$node, $op, $a3 = NULL, $a4 = NULL) {
  switch ($op) {
    case 'view':
			drupal_add_css(drupal_get_path('module', 'annotation') .'/annotation.css');

			drupal_add_js(drupal_get_path('module', 'annotation') .'/jquery.textchildren.js');
			drupal_add_js(drupal_get_path('module', 'annotation') .'/jquery.wrapSelection.js');
      drupal_add_js(drupal_get_path('module', 'annotation') .'/annotation.js');
      
			drupal_add_js(
				array(
					'annotation' => array(
						'sections' => array('#node-'. $node->nid .' .content' => 'node'),
					)
				), 'setting');
      break;
		case 'load':
			// TODO: find a better way of passing filter context
			$node->body = $node->body . "<!-- annotation-nid:". $node->nid ." -->";
			$node->teaser = $node->teaser . "<!-- annotation-nid:". $node->nid ." -->";
			return $result;
  }
}

function annotation_comment(&$a1, $op) {
  switch ($op) {
    case 'insert':
			drupal_set_message(__FUNCTION__ .': '. __LINE__ .' -- '. print_r($a1, TRUE));
			$node = node_load($a1['nid']);
			
			if (!empty($a1['annotation'])) {
				foreach ($a1['annotation'] as $idx => $annotation) {
					db_query('INSERT INTO {annotation} (cid, vid, offset, length, string) VALUES (%d, %d, %d, %d, "%s")', $a1['cid'], $node->vid, $annotation['offset'], $annotation['length'], $annotation['string']);
				}
			}
			
			// clear filter cache for this node
			cache_clear_all($node->format .':'. md5($node->body), 'cache_filter');
			cache_clear_all($node->format .':'. md5($node->teaser), 'cache_filter');
      break;
    case 'delete':
      db_query('DELETE FROM {annotation} WHERE cid=%d', $a1->cid);
      break;
  }
}

function annotation_form_comment_form_alter(&$form, &$form_state) {
	//drupal_set_message(__FUNCTION__ .': '. __LINE__ .' -- '. print_r($form, TRUE));
	//drupal_set_message(__FUNCTION__ .': '. __LINE__ .' -- '. print_r($form_state, TRUE));
	
	/*
	$form['annotation_offset'] = array(
		'#type' => 'hidden',
		'#value' => (!empty($form_state['post']['annotation_offset'])) ? $form_state['post']['annotation_offset'] : '',
	);
	$form['annotation_length'] = array(
		'#type' => 'hidden',
		'#value' => (!empty($form_state['post']['annotation_offset'])) ? $form_state['post']['annotation_length'] : '',
	);
	$form['annotation_string'] = array(
		'#type' => 'hidden',
		'#value' => (!empty($form_state['post']['annotation_offset'])) ? $form_state['post']['annotation_string'] : '',
	);
	*/
	
	if (!empty($form_state['post']['annotation'])) {
		$form['annotation'] = array(
			'#tree' => 'true',
		);
		foreach ($form_state['post']['annotation'] as $idx => $annotation) {
			$form['annotation'][$idx]['offset'] = array(
				'#type' => 'hidden',
				'#value' => $form_state['post']['annotation'][$idx]['offset'],
			);
			$form['annotation'][$idx]['length'] = array(
				'#type' => 'hidden',
				'#value' => $form_state['post']['annotation'][$idx]['length'],
			);
			$form['annotation'][$idx]['string'] = array(
				'#type' => 'hidden',
				'#value' => $form_state['post']['annotation'][$idx]['string'],
			);
		}
	}
}

function annotation_filter($op, $delta = 0, $format = -1, $text = '', $cache_id = 0) {
  switch ($op) {
    case 'list':
      return array(
				0 => t('Annotation filter'),
			);

    case 'description':
      switch ($delta) {
        case 0:
          return t('Attaches user annotations to text.');
        default:
          return;
      }

    case 'process':
      switch ($delta) {
        case 0:
          return annotation_filter_process($text, $format);
        default:
          return $text;
      }

    case 'settings':
      switch ($delta) {
        //case 0:
          //return annotations_filter_settings($format);
        default:
          return;
      }

		case 'no cache':
			return TRUE; // This is only for debugging

    default:
      return $text;
  }
}

function annotation_filter_process($text, $format) {
	//drupal_set_message(__FUNCTION__ .': '. __LINE__ .' -- '. print_r($text, TRUE));
	//drupal_set_message(__FUNCTION__ .': '. __LINE__ .' -- '. print_r($format, TRUE));
	
	if (preg_match('@<!-- annotation-nid:(\d+) -->@i', $text, $matches)) {
		// our context
		$nid = $matches[1];
		$node = node_load($nid);
		
		/*
		if (preg_match_all('@</?\w+((\s+\w+(\s*=\s*(?:".*?"|\'.*?\'|[^\'">\s]+))?)+\s*|\s*)/?>|<!--.*?-->@', '<a href="https://www.some.where/test?stuff=test&blue#test">'. $text .'</a>', $matches, PREG_OFFSET_CAPTURE)) {
			drupal_set_message(__FUNCTION__ .': '. __LINE__ .' -- '. print_r($matches, TRUE));
		}
		if (preg_match_all('@<!--.*?-->@', $text, $matches, PREG_OFFSET_CAPTURE)) {
			drupal_set_message(__FUNCTION__ .': '. __LINE__ .' -- '. print_r($matches, TRUE));
		}
		*/
		
		$currAdjustment = 0;
		$adjustments = annotation_get_offset_adjustments($text);
		//drupal_set_message(__FUNCTION__ .': '. __LINE__ .' -- '. print_r($adjustments, TRUE));
		
		// strip all html tags
		$clean = strip_tags($text);
		
		$result = db_query("SELECT * FROM {annotation} WHERE vid=%d ORDER BY offset", $node->vid);
		while ($annotation = db_fetch_object($result)) {
			//drupal_set_message(__FUNCTION__ .': '. __LINE__ .' -- '. print_r($annotation, TRUE));
			//drupal_set_message(__FUNCTION__ .': '. __LINE__ .' -- '. print_r(substr($clean, $annotation->offset, $annotation->length), TRUE));
			
			// closest match
			// TODO: find a better algorithm
			if (($pos = annotation_closest_match($clean, $annotation->string, $annotation->offset, $annotation->length)) !== FALSE) {
				//drupal_set_message(__FUNCTION__ .': '. __LINE__ .' -- '. print_r($pos, TRUE));
				//drupal_set_message(__FUNCTION__ .': '. __LINE__ .' -- '. print_r(substr($clean, $pos, $annotation->length), TRUE));
			
				// correct offset for html tags and insertions
				//drupal_set_message(__FUNCTION__ .': '. __LINE__ .' -- '. print_r($currAdjustment, TRUE));
				$pos = annotation_correct_offset($pos, $adjustments) + $currAdjustment;
				//drupal_set_message(__FUNCTION__ .': '. __LINE__ .' -- '. print_r($pos, TRUE));
				//drupal_set_message(__FUNCTION__ .': '. __LINE__ .' -- '. print_r(substr($text, $pos, $annotation->length), TRUE));
			
				$newString = '<span class="annotation annotation-'. $annotation->cid .'">'. $annotation->string .'</span>';
				$text = substr_replace($text, $newString, $pos, strlen($annotation->string));
				$currAdjustment += strlen($newString) - strlen($annotation->string);
				//drupal_set_message(__FUNCTION__ .': '. __LINE__ .' -- '. print_r($text, TRUE));
			}
			//drupal_set_message(__FUNCTION__ .': '. __LINE__ .' -- '. print_r($pos, TRUE));
		}
	}
	
	return $text;
}

function annotation_correct_offset($offset, $adjustments) {
	foreach ($adjustments as $pos => $string) {
		if ($pos < $offset) {
			$offset += strlen($string);
		}
	}
	
	return $offset;
}

function annotation_get_offset_adjustments($html) {
	$adjustments = array();
	
	// match html tags/comments
	if (preg_match_all('@</?\w+((\s+\w+(\s*=\s*(?:".*?"|\'.*?\'|[^\'">\s]+))?)+\s*|\s*)/?>|<!--.*?-->@', $html, $matches, PREG_OFFSET_CAPTURE, $offset)) {
		foreach ($matches[0] as $match) {
			$adjustments[$match[1]] = $match[0];
		}
	}
	
	return $adjustments;
}

function annotation_closest_match($haystack, $needle, $target, $length) {
	$results = array();
	$bestPos = FALSE;
	
	// get positions
	$pos = strpos($haystack, $needle);
	while ($pos !== FALSE) {
		$results[] = $pos;
		$pos = strpos($haystack, $needle, $pos + 1);
	}
	
	// find closest match
	if (count($results)) {
		$bestDiff = strlen($haystack) * 2; // extreme amount
		foreach ($results as $pos) {
			$diff = abs($target - $pos);
			if ($diff < $bestDiff) {
				$bestDiff = $diff;
				$bestPos = $pos;
			}
		}
	}
	
	return $bestPos;
}
