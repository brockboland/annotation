<?php

/**
 * Implementation of hook_menu
 */
function annotation_text_menu() {
  $items = array();

  $items['annotation_text/form/%node'] = array(
    'title' => t('RSS feed'),
    'page callback' => 'annotation_text_annotate_ajax_form',
    'page arguments' => array(2),
    'access callback' => 'annotation_text_annotate_form_access',
    'access arguments' => array(2),
    'type' => MENU_CALLBACK,
  );
  
  return $items;
}

/**
 * Implementation of hook_node_info
 */
function annotation_text_node_info() {
  return array(
    'annotation_text' => array(
      'name' => t('Text Annotations'),
      'module' => 'annotation_text',
      'description' => t('A text annotations.'),
      'has_body' => TRUE,
      'body_label' => t('Description'),
    ),
  );
}

/**
 * Node form for default annotation text node type
 */
function annotation_text_form(&$node, $form_state) {
  return node_content_form($node, $form_state);
}

/**
 * Access check for AJAX comment form
 */
function annotation_text_annotate_form_access($node) {
  return (user_access('post comments') && (node_comment_mode($node->nid) == COMMENT_NODE_READ_WRITE));
}

function annotation_text_annotate_ajax_form($node) {
  print drupal_get_form('comment_form', array('nid' => $node->nid));
  exit();
}

/**
 * Implementation of hook_nodeapi
 */
function annotation_text_nodeapi(&$node, $op, $a3 = NULL, $a4 = NULL) {
  switch ($op) {
    case 'view':
      if ($node->type == 'annotation_text') {
        // include css
        drupal_add_css(drupal_get_path('module', 'annotation_text') .'/annotation_text.css');
        annotation_add_css();

        // include js
        drupal_add_js(drupal_get_path('module', 'annotation_text') .'/jquery.textchildren.js');
        drupal_add_js(drupal_get_path('module', 'annotation_text') .'/jquery.wrapSelection.js');
        drupal_add_js(drupal_get_path('module', 'annotation_text') .'/annotation_text.js');
        annotation_add_js();

        // wrap node body in base annotation_text element
        // this is required to remove dependence on theme, and remove extra white space
        $node->content['body']['#value'] = '<div class="annotation-text-body">'. $node->content['body']['#value'] .'</div>';

        // add in config data
        drupal_add_js(
          array(
            'annotation_text' => array(
              'nid' => $node->nid,
              'sections' => array('#node-'. $node->nid .' .annotation-text-body' => 'node'),
              'url' => array(
                'form' => url('annotation_text/form'),
              ),
            )
          ),
          'setting'
        );  
      }

      break;
    case 'load':
      // TODO: find a better way of passing filter context
      if ($node->type == 'annotation_text') {
        $node->body = _annotation_text_add_context($node->body, $node);
        $node->teaser = _annotation_text_add_context($node->teaser, $node);
      }
  }
}

/**
 * Helper that adds node context to node body, for later use in filter stage
 */
function _annotation_text_add_context($text, $node) {
  // strip previous contexts
  $text = preg_replace('@<!-- annotation_text-nid:\d+ -->@i', '', $text);
  
  // add context
  $text .= "<!-- annotation_text-nid:". $node->nid ." -->";
  
  return $text;
}

/**
 * Implementation of hook_comment
 */
function annotation_text_comment(&$a1, $op) {
  switch ($op) {
    case 'insert':
      $node = node_load($a1['nid']);

      if (!empty($a1['annotation_text'])) {
        foreach ($a1['annotation_text'] as $idx => $annotation_text) {
          db_query('INSERT INTO {annotation_text} (cid, vid, offset, length, string) VALUES (%d, %d, %d, %d, "%s")', $a1['cid'], $node->vid, $annotation_text['offset'], $annotation_text['length'], $annotation_text['string']);
        }
      }

      // clear filter cache for this node
      cache_clear_all($node->format .':'. md5($node->body), 'cache_filter');
      cache_clear_all($node->format .':'. md5($node->teaser), 'cache_filter');
      break;

    case 'delete':
      db_query('DELETE FROM {annotation_text} WHERE cid=%d', $a1->cid);
      break;
  }
}

/**
 * Implementation of hook_FORM_ID_form_alter
 * Add annotation information into comment form, so it's not lost
 */
function annotation_text_form_panels_comment_form_alter(&$form, &$form_state) {
  annotation_text_form_comment_form_alter(&$form, &$form_state);
}
function annotation_text_form_comment_form_alter(&$form, &$form_state) {
  // add annotation offset form elements if found in POST
  if (!empty($form_state['post']['annotation_text'])) {
    $form['annotation_text'] = array(
      '#tree' => 'true',
    );
    foreach ($form_state['post']['annotation_text'] as $idx => $annotation_text) {
      $form['annotation_text'][$idx]['offset'] = array(
        '#type' => 'hidden',
        '#value' => $form_state['post']['annotation_text'][$idx]['offset'],
      );
      $form['annotation_text'][$idx]['length'] = array(
        '#type' => 'hidden',
        '#value' => $form_state['post']['annotation_text'][$idx]['length'],
      );
      $form['annotation_text'][$idx]['string'] = array(
        '#type' => 'hidden',
        '#value' => $form_state['post']['annotation_text'][$idx]['string'],
      );
    }
  }
}

/**
 * Implementation of hook_filter
 */
function annotation_text_filter($op, $delta = 0, $format = -1, $text = '', $cache_id = 0) {
  switch ($op) {
    case 'list':
      return array(
        0 => t('Annotation filter'),
      );

    case 'description':
      switch ($delta) {
        case 0:
          return t('Attaches user annotation_texts to text.');

        default:
          return;
      }

    case 'process':
      switch ($delta) {
        case 0:
          return annotation_text_filter_process($text, $format);

        default:
          return $text;
      }

    case 'no cache':
      return TRUE; // TODO: Don't cache for now

    default:
      return $text;
  }
}

/**
 * Filter process function that does the heavy lifting
 */
function annotation_text_filter_process($text, $format) {
  if (preg_match('@<!-- annotation_text-nid:(\d+) -->@i', $text, $matches)) {
    // our context
    $nid = $matches[1];
    $node = node_load($nid);
    $annotations = array();
    $corrected_annotations = array();
    $anchors = array();
    
    // generate adjustment list
    $adjustments = _annotation_text_get_offset_adjustments($text);
    
    // strip all html tags
    $clean = _annotation_text_get_clean_text($text, $adjustments);
    
    // get annotations
    $result = db_query("SELECT * FROM {annotation_text} WHERE vid=%d ORDER BY offset ASC, length ASC", $node->vid);
    while ($annotation = db_fetch_object($result)) {
      // match it up
      if (($annotation->matched_offset = _annotation_text_closest_match($clean, $annotation->string, $annotation->offset, $annotation->length)) !== FALSE) {
        // correct matched_offset due to html tags
        $annotation->corrected_offset = _annotation_text_correct_offset($annotation->matched_offset, $adjustments);
        $annotations[] = $annotation;
      }
    }
    
    // split up overlapping annotations
    if (!empty($annotations)) {
      // initialize offset
      $offset = 0;
      
      // split up overlapping annotations
      while (1) {
        $found = FALSE;
        $corrected_annotation = FALSE;
                
        // make sure offset is not in the middle of an html tag
        // go through adjustments as adjust
        foreach ($adjustments as $pos => $tag) {
          if (($pos <= $offset) && ($offset < ($pos + strlen($tag)))) {
            $offset = $pos + strlen($tag);
          }
        }
                
        // find first annotation that contains this offset
        foreach ($annotations as $id => $annotation) {
          if (($annotation->corrected_offset <= $offset) && ($offset < ($annotation->corrected_offset + $annotation->length))) {
            $corrected_annotation = array(
              'offset' => $offset,
              'length' => $annotation->length - ($offset - $annotation->corrected_offset),
              'cids' => array($annotation->cid => $annotation->cid),
            );
            $found = TRUE;
            break;
          }
        }
        
        // if not found, find first annotation AFTER offset
        if (!$found) {
          foreach ($annotations as $id => $annotation) {
            if ($offset < $annotation->corrected_offset) {
              $offset = $annotation->corrected_offset;
              $corrected_annotation = array(
                'offset' => $offset,
                'length' => $annotation->length,
                'cids' => array($annotation->cid => $annotation->cid),
              );
              $found = TRUE;
              break;
            }
          }
        }
        
        // if still not found, then we hit the end
        if (!$found) {
          break;
        }
        
        // now that we found a valid offset to work with
        // go through annotations and adjust
        foreach ($annotations as $id => $annotation) {
          // collect cids if range overlaps
          if (($annotation->corrected_offset <= $offset) && (($annotation->corrected_offset + $annotation->length) > $offset)) {
            $corrected_annotation['cids'][$annotation->cid] = $annotation->cid;
          }
          
          // if same offset, but shorter length
          if (($annotation->corrected_offset == $offset) && ($annotation->length < $corrected_annotation['length'])) {
            $corrected_annotation['length'] = $annotation->length;
          }
          // else, if higher offset, but less than curent length
          elseif (($annotation->corrected_offset > $offset) && ($annotation->corrected_offset <  ($offset + $corrected_annotation['length']))) {
            $corrected_annotation['length'] = $annotation->corrected_offset - $offset;
          }
          // else, if lower offset, but end is in range
          elseif (($annotation->corrected_offset < $offset) && (($annotation->corrected_offset + $annotation->length) > $offset) && (($annotation->corrected_offset + $annotation->length) < ($offset + $corrected_annotation['length']))) {
            $corrected_annotation['length'] = ($annotation->corrected_offset + $annotation->length) - $offset;
          }
        }
        
        // we don't want annotations breaking existing HTML tags
        // go through adjustments and shorten length as necessary
        foreach ($adjustments as $pos => $tag) {
          if (($offset < $pos) && (($pos + strlen($tag)) <= ($offset + $corrected_annotation['length']))) {
            $corrected_annotation['length'] = $pos - $offset;
            break;
          }
        }
        
        // sanity check - we shouldn't have an invalid length at this time
        if ($corrected_annotation['length'] <= 0) {
          break;
        }
        
        // increment offset
        $offset += $corrected_annotation['length'];
        
        $corrected_annotations[] = $corrected_annotation;
      }
      
      // now that annotations are cleaned up, add annotation markup
      $currAdjustment = 0;
      foreach ($corrected_annotations as $corrected_annotation) {
        // generate classes and anchor for this region
        $curr_anchors = array();
        $classes = array('annotation-text');
        foreach ($corrected_annotation['cids'] as $cid) {
          $classes[] = 'annotation-text-cid-'. $cid;
          
          // add an anchor for this cid, if it's the first time we've seen it
          // this will mean there is only an anchor at beginning, even if the annotation spans across boundries
          if (empty($anchors[$cid])) {
            $curr_anchors[] = '<a name="annotation-text-cid-'. $cid .'"></a>';
            $anchors[$cid] = 'annotation-text-cid-'. $cid;
          }
        }
        
        // add class that specifies number of overlapping annotations
        $classes[] = 'annotation-text-'. count($corrected_annotation['cids']);
        
        // generate new string, and replace old string
        $string = substr($text, $corrected_annotation['offset'] + $currAdjustment, $corrected_annotation['length']);
        $newString = '<span class="'. implode(' ', $classes) .'">'. implode('', $curr_anchors) . $string .'</span>';
        $text = substr_replace($text, $newString, $corrected_annotation['offset'] + $currAdjustment, $corrected_annotation['length']);
        
        // adjust on-the-fly adjustment so we continue to insert tags at the right place
        $currAdjustment += strlen($newString) - strlen($string);
      }
    }
  }
  
  return $text;
}

/**
 * Helper function that will correct an offset based upon a list of adjustments
 */
function _annotation_text_correct_offset($offset, $adjustments) {
  foreach ($adjustments as $pos => $string) {
    if ($pos <= $offset) {
      $offset += strlen($string);
    }
  }
  
  return $offset;
}

/**
 * Helper function that generates a list of adjustments based on HTML tags in the text
 */
function _annotation_text_get_offset_adjustments($html) {
  $adjustments = array();
  
  // match html tags/comments
  if (preg_match_all('@</?\w+((\s+\w+(\s*=\s*(?:".*?"|\'.*?\'|[^\'">\s]+))?)+\s*|\s*)/?>|<!--.*?-->@', $html, $matches, PREG_OFFSET_CAPTURE, $offset)) {
    foreach ($matches[0] as $match) {
      $adjustments[$match[1]] = $match[0];
    }
  }
  
  return $adjustments;
}

/**
 * Helper function that generates a copy of the text with all HTML tags removed
 */
function _annotation_text_get_clean_text($html, $adjustments) {
  $text = $html;
  $offset = 0;
  
  foreach ($adjustments as $pos => $tag) {
    $text = substr_replace($text, '', $pos + $offset, strlen($tag));
    $offset -= strlen($tag);
  }
  
  return $text;
}

/**
 * Helper function that finds the match closest to the specified offset data
 */
function _annotation_text_closest_match($haystack, $needle, $target, $length) {
  $results = array();
  $bestPos = FALSE;
  
  // get positions
  $pos = strpos($haystack, $needle);
  while ($pos !== FALSE) {
    $results[] = $pos;
    $pos = strpos($haystack, $needle, $pos + 1);
  }
  
  // find closest match
  if (count($results)) {
    $bestDiff = strlen($haystack) * 2; // extreme amount
    foreach ($results as $pos) {
      $diff = abs($target - $pos);
      if ($diff < $bestDiff) {
        $bestDiff = $diff;
        $bestPos = $pos;
      }
    }
  }
  
  return $bestPos;
}
