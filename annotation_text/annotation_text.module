<?php

function annotation_text_form_node_type_form_alter(&$form, &$form_state) {
  $form['submission']['body_annotation_text'] = array(
    '#type' => 'checkbox',
    '#title' => t('Annotate body field'),
    '#default_value' => variable_get('annotation_text_body_'. $form['#node_type']->type, FALSE), 
  );
  $form['#submit'][] = 'annotation_text_form_node_type_form_submit';
}

function annotation_text_form_node_type_form_submit($form, &$form_state) {
  variable_set('annotation_text_body_'. $form['#node_type']->type, $form_state['values']['body_annotation_text']);
}

/**
 * Implements hook_nodeapi().
 */
function annotation_text_nodeapi(&$node, $op, $a3 = NULL, $a4 = NULL) {
  if (user_access('access comments') && variable_get('annotation_text_body_'. $node->type, FALSE)) {
    switch ($op) {
      case 'view':
        annotation_add_js($node, 'annotation_text', array('offset', 'length', 'string'));
        drupal_add_js(drupal_get_path('module', 'annotation_text') .'/jquery.wrapSelection.js');
        drupal_add_js(drupal_get_path('module', 'annotation_text') .'/annotation_text.js');
        drupal_add_css(drupal_get_path('module', 'annotation_text') .'/annotation_text.css');

        // Wrap node body in base annotation_text element. This is required to
        // remove dependence on theme, and remove extra white space.
        $node->content['body']['#value'] = '<div class="annotation-text-body">'. $node->content['body']['#value'] .'</div>';

        // add in config data
        drupal_add_js(array('annotation_text' => array(
          'sections' => array('#node-'. $node->nid .' .annotation-text-body' => 'node'),
          'prompt' => '<a class="annotation-text-selected-link" href="#">'. t('Annotate') .'</a>',
        )), 'setting');  
        break;

      case 'load':
        $node->body = annotation_text_add_markup($node->body, $node);
        $node->teaser = annotation_text_add_markup($node->teaser, $node, TRUE);
        break;
      case 'presave':
        // Handle version changes.
        if ($node->nid && preg_match_all('@<span class="annotation annotation-cid-(\d+) annotation-text-(\d+)">@i', $node->body, $matches)) {
          if (count($matches[1])) {
            foreach ($matches[1] as $key => $cid) {
              // Get the new offset, length, and string
              $offset = strpos($node->body, $matches[0][$key]);
              // TODO: test with line breaks etc. Did this ever work across linebreaks??
              preg_match('@' . $matches[0][$key] . '(.*?)</span>@i', $node->body, $selections);
              $string = $selections[1];
              $replacements[] = array(
                'string' => $string,
                'span' => $selections[0],
              );
              $length = strlen($string);
              // Update the text_annotations data.
              $annotation = array(
                'cid' => $cid,
                'offset' => $offset,
                'length' => $length,
                'string' => $string,
              );
              // We cannot save the revised annotations during presave,
              // as we do not know the new vid of the node.
              // Store them in the node to use on update.
              $node->annotation_text[] = $annotation;
            }
            // Remove annotation spans from markup before saving.
            if (count($replacements)) {
              foreach ($replacements as $replacement) {
                $node->body = str_replace($replacement['span'], $replacement['string'], $node->body);
                $node->teaser = str_replace($replacement['span'], $replacement['string'], $node->teaser);
              }
            }
          }
        }
        break;
      case 'update':
        // Annotation updates and new revisions are added here now that the
        // $node->vid is known.
        $cids = array();
        if (isset($node->annotation_text) && count($node->annotation_text)) {
          foreach ($node->annotation_text as $annotation) {
            // Ensure this is a valid comment with a record for this node.
            if (db_result(db_query("SELECT cid FROM {comments} WHERE nid = %d AND cid = %d", $node->nid, $annotation['cid']))) {
              $cids[$annotation['cid']] = 1;
              $annotation['vid'] = $node->vid;
              $update = db_result(db_query("SELECT vid FROM {annotation_text} WHERE cid = %d and vid = %d", $annotation['cid'], $node->vid));

              if ($update) {
                drupal_write_record('annotation_text', $annotation, array('cid', 'vid'));
              }
              else {
                // A new revision is being created, which needs a new record.
                drupal_write_record('annotation_text', $annotation);
              }
            }
          }
        }
        // Remove any old annotations for this vid if they were removed
        // during edit. (Leave them as regular comments only)
        $result = db_query("SELECT cid FROM {annotation_text} WHERE vid = %d", $node->vid);
        while ($cid = db_result($result)) {
          if (!isset($cids[$cid])) {
            db_query("DELETE FROM {annotation_text} WHERE cid = %d AND vid = %d", $cid, $node->vid);
          }
        }
        break;
    }
  }
}

/**
 * Implements hook_comment().
 */
function annotation_text_comment(&$a1, $op) {
  switch ($op) {
    case 'insert':
    case 'update':
      $node = node_load($a1['nid']);
      if (isset($a1['annotation_text'])) {
        $a1['annotation_text']['cid'] = $a1['cid'];
        $a1['annotation_text']['vid'] = $node->vid;
        $annotations = annotation_text_annotations($node->vid);
        if (!isset($annotations['c'. $a1['cid']])) {
          drupal_write_record('annotation_text', $a1['annotation_text']);
        }
      }
      break;

    case 'delete':
      db_query('DELETE FROM {annotation_text} WHERE cid = %d', $a1->cid);
      break;
  }
}

/**
 * Load annotations for a node version.
 */
function annotation_text_annotations($vid) {
  static $annotations = array();

  if (!isset($annotations[$vid])) {
    $annotations[$vid] = array();
    $result = db_query("SELECT * FROM {annotation_text} WHERE vid = %d ORDER BY offset ASC, length ASC", $vid);
    while ($annotation = db_fetch_object($result)) {
      $annotations[$vid]['c'. $annotation->cid] = $annotation;
      $annotations[$vid]['c'. $annotation->cid]->options = 'textAnnotationOptions';
    }
  }

  return $annotations[$vid];
}


/**
 * Add the annotations to the text.
 */
function annotation_text_add_markup($text, $node, $teaser = FALSE) {
  $annotations = array();
  $corrected_annotations = array();

  // generate adjustment list
  $adjustments = _annotation_text_get_offset_adjustments($text);

  // strip all html tags
  $clean = _annotation_text_get_clean_text($text, $adjustments);

  $result = db_query("SELECT * FROM {annotation_text} WHERE vid = %d ORDER BY offset ASC, length ASC", $node->vid);
  while ($annotation = db_fetch_object($result)) {
    // Don't try to match annotations into teasers if their offset is past the teaser length.
    if (!$teaser || $annotation->offset < strlen($text)) {
      // match it up
      if (($annotation->matched_offset = _annotation_text_closest_match($clean, $annotation->string, $annotation->offset, $annotation->length)) !== FALSE) {
        // correct matched_offset due to html tags
        $annotation->corrected_offset = _annotation_text_correct_offset($annotation->matched_offset, $adjustments);
        $annotation->corrected_length = _annotation_text_correct_offset($annotation->matched_offset + $annotation->length, $adjustments) - $annotation->corrected_offset;
        $annotations[] = $annotation;
      }
    }
  }

  // split up overlapping annotations
  if (!empty($annotations)) {
    // initialize offset
    $offset = 0;

    // split up overlapping annotations
    while (1) {
      $found = FALSE;
      $corrected_annotation = FALSE;

      // make sure offset is not in the middle of an html tag
      // go through adjustments as adjust
      foreach ($adjustments as $pos => $tag) {
        if (($pos <= $offset) && ($offset < ($pos + strlen($tag)))) {
          $offset = $pos + strlen($tag);
        }
      }

      // find first annotation that contains this offset
      foreach ($annotations as $id => $annotation) {
        if (($annotation->corrected_offset <= $offset) && ($offset < ($annotation->corrected_offset + $annotation->length))) {
          $corrected_annotation = array(
            'offset' => $offset,
            'length' => $annotation->corrected_length - ($offset - $annotation->corrected_offset),
            'cids' => array($annotation->cid => $annotation->cid),
          );
          $found = TRUE;
          break;
        }
      }

      // if not found, find first annotation AFTER offset
      if (!$found) {
        foreach ($annotations as $id => $annotation) {
          if ($offset < $annotation->corrected_offset) {
            $offset = $annotation->corrected_offset;
            $corrected_annotation = array(
              'offset' => $offset,
              'length' => $annotation->corrected_length,
              'cids' => array($annotation->cid => $annotation->cid),
            );
            $found = TRUE;
            break;
          }
        }
      }

      // if still not found, then we hit the end
      if (!$found) {
        break;
      }

      // now that we found a valid offset to work with
      // go through annotations and adjust
      foreach ($annotations as $id => $annotation) {
        // collect cids if range overlaps
        if (($annotation->corrected_offset <= $offset) && (($annotation->corrected_offset + $annotation->length) > $offset)) {
          $corrected_annotation['cids'][$annotation->cid] = $annotation->cid;
        }

        // if same offset, but shorter length
        if (($annotation->corrected_offset == $offset) && ($annotation->length < $corrected_annotation['length'])) {
          $corrected_annotation['length'] = $annotation->corrected_length;
        }
        // else, if higher offset, but less than curent length
        elseif (($annotation->corrected_offset > $offset) && ($annotation->corrected_offset < ($offset + $corrected_annotation['length']))) {
          $corrected_annotation['length'] = $annotation->corrected_offset - $offset;
        }
        // else, if lower offset, but end is in range
        elseif (($annotation->corrected_offset < $offset) && (($annotation->corrected_offset + $annotation->length) > $offset) && (($annotation->corrected_offset + $annotation->length) < ($offset + $corrected_annotation['length']))) {
          $corrected_annotation['length'] = ($annotation->corrected_offset + $annotation->corrected_length) - $offset;
        }
      }

      // we don't want annotations breaking existing HTML tags
      // go through adjustments and shorten length as necessary
      foreach ($adjustments as $pos => $tag) {
        if (($offset < $pos) && (($pos + strlen($tag)) <= ($offset + $corrected_annotation['length']))) {
          $corrected_annotation['length'] = $pos - $offset;
          break;
        }
      }

      // sanity check - we shouldn't have an invalid length at this time
      if ($corrected_annotation['length'] <= 0) {
        break;
      }

      // increment offset
      $offset += $corrected_annotation['length'];

      $corrected_annotations[] = $corrected_annotation;
    }

    // Now that annotations are cleaned up, add annotation markup.
    $currAdjustment = 0;
    foreach ($corrected_annotations as $corrected_annotation) {
      // generate classes and anchor for this region
      $classes = array('annotation');
      foreach ($corrected_annotation['cids'] as $cid) {
        $classes[] = 'annotation-cid-'. $cid;
      }

      // Add class that specifies number of overlapping annotations.
      $classes[] = 'annotation-text-'. count($corrected_annotation['cids']);

      // Generate new string, and replace old string.
      $string = substr($text, $corrected_annotation['offset'] + $currAdjustment, $corrected_annotation['length']);
      $newString = '<span class="'. implode(' ', $classes) .'">'. $string .'</span>';
      $text = substr_replace($text, $newString, $corrected_annotation['offset'] + $currAdjustment, $corrected_annotation['length']);

      // Adjust on-the-fly adjustment so we continue to insert tags at
      // the right place.
      $currAdjustment += strlen($newString) - strlen($string);
    }
  }

  return $text;
}

/**
 * Helper function that will correct an offset based upon a list of adjustments
 */
function _annotation_text_correct_offset($offset, $adjustments) {
  foreach ($adjustments as $pos => $string) {
    if ($pos <= $offset) {
      $offset += strlen($string);
    }
  }

  return $offset;
}

/**
 * Helper function that generates a list of adjustments based on HTML tags in
 * the text
 */
function _annotation_text_get_offset_adjustments($html) {
  $adjustments = array();

  // match html tags/comments
  if (preg_match_all('@</?\w+((\s+\w+(\s*=\s*(?:".*?"|\'.*?\'|[^\'">\s]+))?)+\s*|\s*)/?>|<!--.*?-->|\n+@', $html, $matches, PREG_OFFSET_CAPTURE)) {
    foreach ($matches[0] as $match) {
      $adjustments[$match[1]] = $match[0];
    }
  }

  return $adjustments;
}

/**
 * Helper function that generates a copy of the text with all HTML tags removed
 */
function _annotation_text_get_clean_text($html, $adjustments) {
  $text = $html;
  $offset = 0;

  foreach ($adjustments as $pos => $tag) {
    $text = substr_replace($text, '', $pos + $offset, strlen($tag));
    $offset -= strlen($tag);
  }

  return $text;
}

/**
 * Helper function that finds the match closest to the specified offset data
 */
function _annotation_text_closest_match($haystack, $needle, $target, $length) {
  $results = array();
  $bestPos = FALSE;

  // get positions
  $pos = strpos($haystack, $needle);
  while ($pos !== FALSE) {
    $results[] = $pos;
    $pos = strpos($haystack, $needle, $pos + 1);
  }

  // find closest match
  if (count($results)) {
    $bestDiff = strlen($haystack) * 2; // extreme amount
    foreach ($results as $pos) {
      $diff = abs($target - $pos);
      if ($diff < $bestDiff) {
        $bestDiff = $diff;
        $bestPos = $pos;
      }
    }
  }

  return $bestPos;
}
