<?php

/**
 * Implementation of hook_node_info
 */
function annotation_text_node_info() {
  return array(
    'annotation_text' => array(
      'name' => t('Text Annotations'),
      'module' => 'annotation_text',
      'description' => t('A text annotations.'),
      'has_body' => TRUE,
      'body_label' => t('Description'),
    ),
  );
}

/**
 * Node form for default annotation text node type
 */
function annotation_text_form(&$node, $form_state) {
  return node_content_form($node, $form_state);
}

/**
 * Implementation of hook_nodeapi
 */
function annotation_text_nodeapi(&$node, $op, $a3 = NULL, $a4 = NULL) {
  switch ($op) {
    case 'view':
      if ($node->type == 'annotation_text') {
        annotation_add_js($node, 'annotation_text', array('offset', 'length', 'string'));
        drupal_add_js(drupal_get_path('module', 'annotation_text') .'/jquery.wrapSelection.js');
        drupal_add_js(drupal_get_path('module', 'annotation_text') .'/annotation_text.js');
        drupal_add_css(drupal_get_path('module', 'annotation_text') .'/annotation_text.css');

        // Wrap node body in base annotation_text element. This is required to
        // remove dependence on theme, and remove extra white space.
        $node->content['body']['#value'] = '<div class="annotation-text-body">'. $node->content['body']['#value'] .'</div>';

        // add in config data
        drupal_add_js(array('annotation_text' => array(
          'sections' => array('#node-'. $node->nid .' .annotation-text-body' => 'node'),
          'prompt' => '<a class="annotation-text-selected-link" href="#">'. t('Annotate') .'</a>',
        )), 'setting');  
      }
      break;

    case 'load':
      // TODO: find a better way of passing filter context
      if ($node->type == 'annotation_text') {
        $node->body = _annotation_text_add_context($node->body, $node);
        $node->teaser = _annotation_text_add_context($node->teaser, $node);
      }
      break;
  }
}

/**
 * Helper that adds node context to node body, for later use in filter stage
 */
function _annotation_text_add_context($text, $node) {
  // strip previous contexts
  $text = preg_replace('@<!-- annotation_text-nid:\d+ -->@i', '', $text);
  
  // add context
  $text .= "<!-- annotation_text-nid:". $node->nid ." -->";
  
  return $text;
}

/**
 * Implementation of hook_comment.
 */
function annotation_text_comment(&$a1, $op) {
  switch ($op) {
    case 'insert':
    case 'update':
      $node = node_load($a1['nid']);
      if (isset($a1['annotation_text'])) {
        $a1['annotation_text']['cid'] = $a1['cid'];
        $a1['annotation_text']['vid'] = $node->vid;
        drupal_write_record('annotation_text', $a1['annotation_text']);

        cache_clear_all($node->format .':'. md5($node->body), 'cache_filter');
        cache_clear_all($node->format .':'. md5($node->teaser), 'cache_filter');
      }
      break;

    case 'delete':
      db_query('DELETE FROM {annotation_text} WHERE cid = %d', $a1->cid);
      break;
  }
}

/**
 * Implementation of hook_filter
 */
function annotation_text_filter($op, $delta = 0, $format = -1, $text = '', $cache_id = 0) {
  switch ($op) {
    case 'list':
      return array(
        0 => t('Annotation filter'),
      );

    case 'description':
      switch ($delta) {
        case 0:
          return t('Attaches user annotation_texts to text.');

        default:
          return;
      }

    case 'process':
      switch ($delta) {
        case 0:
          return annotation_text_filter_process($text, $format);

        default:
          return $text;
      }

    case 'no cache':
      return TRUE; // TODO: Don't cache for now

    default:
      return $text;
  }
}

/**
 * Load annotations for a node version.
 */
function annotation_text_annotations($vid) {
  static $annotations = array();

  if (!isset($annotations[$vid])) {
    $annotations[$vid] = array();
    $result = db_query("SELECT * FROM {annotation_text} WHERE vid = %d ORDER BY offset ASC, length ASC", $vid);
    while ($annotation = db_fetch_object($result)) {
      $annotations[$vid]['c'. $annotation->cid] = $annotation;
    }
  }

  return $annotations[$vid];
}

/**
 * Filter process function that does the heavy lifting
 */
function annotation_text_filter_process($text, $format) {
  if (preg_match('@<!-- annotation_text-nid:(\d+) -->@i', $text, $matches)) {
    // our context
    $nid = $matches[1];
    $node = node_load($nid);
    $annotations = array();
    $corrected_annotations = array();
    
    // generate adjustment list
    $adjustments = _annotation_text_get_offset_adjustments($text);
    
    // strip all html tags
    $clean = _annotation_text_get_clean_text($text, $adjustments);
    
    foreach (annotation_text_annotations($node->vid) as $annotation) {
      // match it up
      if (($annotation->matched_offset = _annotation_text_closest_match($clean, $annotation->string, $annotation->offset, $annotation->length)) !== FALSE) {
        // correct matched_offset due to html tags
        $annotation->corrected_offset = _annotation_text_correct_offset($annotation->matched_offset, $adjustments);
        $annotations[] = $annotation;
      }
    }
    
    // split up overlapping annotations
    if (!empty($annotations)) {
      // initialize offset
      $offset = 0;
      
      // split up overlapping annotations
      while (1) {
        $found = FALSE;
        $corrected_annotation = FALSE;
                
        // make sure offset is not in the middle of an html tag
        // go through adjustments as adjust
        foreach ($adjustments as $pos => $tag) {
          if (($pos <= $offset) && ($offset < ($pos + strlen($tag)))) {
            $offset = $pos + strlen($tag);
          }
        }
                
        // find first annotation that contains this offset
        foreach ($annotations as $id => $annotation) {
          if (($annotation->corrected_offset <= $offset) && ($offset < ($annotation->corrected_offset + $annotation->length))) {
            $corrected_annotation = array(
              'offset' => $offset,
              'length' => $annotation->length - ($offset - $annotation->corrected_offset),
              'cids' => array($annotation->cid => $annotation->cid),
            );
            $found = TRUE;
            break;
          }
        }
        
        // if not found, find first annotation AFTER offset
        if (!$found) {
          foreach ($annotations as $id => $annotation) {
            if ($offset < $annotation->corrected_offset) {
              $offset = $annotation->corrected_offset;
              $corrected_annotation = array(
                'offset' => $offset,
                'length' => $annotation->length,
                'cids' => array($annotation->cid => $annotation->cid),
              );
              $found = TRUE;
              break;
            }
          }
        }
        
        // if still not found, then we hit the end
        if (!$found) {
          break;
        }
        
        // now that we found a valid offset to work with
        // go through annotations and adjust
        foreach ($annotations as $id => $annotation) {
          // collect cids if range overlaps
          if (($annotation->corrected_offset <= $offset) && (($annotation->corrected_offset + $annotation->length) > $offset)) {
            $corrected_annotation['cids'][$annotation->cid] = $annotation->cid;
          }
          
          // if same offset, but shorter length
          if (($annotation->corrected_offset == $offset) && ($annotation->length < $corrected_annotation['length'])) {
            $corrected_annotation['length'] = $annotation->length;
          }
          // else, if higher offset, but less than curent length
          elseif (($annotation->corrected_offset > $offset) && ($annotation->corrected_offset < ($offset + $corrected_annotation['length']))) {
            $corrected_annotation['length'] = $annotation->corrected_offset - $offset;
          }
          // else, if lower offset, but end is in range
          elseif (($annotation->corrected_offset < $offset) && (($annotation->corrected_offset + $annotation->length) > $offset) && (($annotation->corrected_offset + $annotation->length) < ($offset + $corrected_annotation['length']))) {
            $corrected_annotation['length'] = ($annotation->corrected_offset + $annotation->length) - $offset;
          }
        }
        
        // we don't want annotations breaking existing HTML tags
        // go through adjustments and shorten length as necessary
        foreach ($adjustments as $pos => $tag) {
          if (($offset < $pos) && (($pos + strlen($tag)) <= ($offset + $corrected_annotation['length']))) {
            $corrected_annotation['length'] = $pos - $offset;
            break;
          }
        }
        
        // sanity check - we shouldn't have an invalid length at this time
        if ($corrected_annotation['length'] <= 0) {
          break;
        }
        
        // increment offset
        $offset += $corrected_annotation['length'];
        
        $corrected_annotations[] = $corrected_annotation;
      }
      
      // Now that annotations are cleaned up, add annotation markup.
      $currAdjustment = 0;
      foreach ($corrected_annotations as $corrected_annotation) {
        // generate classes and anchor for this region
        $classes = array('annotation');
        foreach ($corrected_annotation['cids'] as $cid) {
          $classes[] = 'annotation-cid-'. $cid;
        }
        
        // Add class that specifies number of overlapping annotations.
        $classes[] = 'annotation-text-'. count($corrected_annotation['cids']);
        
        // Generate new string, and replace old string.
        $string = substr($text, $corrected_annotation['offset'] + $currAdjustment, $corrected_annotation['length']);
        $newString = '<span class="'. implode(' ', $classes) .'">'. $string .'</span>';
        $text = substr_replace($text, $newString, $corrected_annotation['offset'] + $currAdjustment, $corrected_annotation['length']);
        
        // Adjust on-the-fly adjustment so we continue to insert tags at
        // the right place.
        $currAdjustment += strlen($newString) - strlen($string);
      }
    }
  }
  
  return $text;
}

/**
 * Helper function that will correct an offset based upon a list of adjustments
 */
function _annotation_text_correct_offset($offset, $adjustments) {
  foreach ($adjustments as $pos => $string) {
    if ($pos <= $offset) {
      $offset += strlen($string);
    }
  }
  
  return $offset;
}

/**
 * Helper function that generates a list of adjustments based on HTML tags in the text
 */
function _annotation_text_get_offset_adjustments($html) {
  $adjustments = array();
  
  // match html tags/comments
  if (preg_match_all('@</?\w+((\s+\w+(\s*=\s*(?:".*?"|\'.*?\'|[^\'">\s]+))?)+\s*|\s*)/?>|<!--.*?-->@', $html, $matches, PREG_OFFSET_CAPTURE, $offset)) {
    foreach ($matches[0] as $match) {
      $adjustments[$match[1]] = $match[0];
    }
  }
  
  return $adjustments;
}

/**
 * Helper function that generates a copy of the text with all HTML tags removed
 */
function _annotation_text_get_clean_text($html, $adjustments) {
  $text = $html;
  $offset = 0;
  
  foreach ($adjustments as $pos => $tag) {
    $text = substr_replace($text, '', $pos + $offset, strlen($tag));
    $offset -= strlen($tag);
  }
  
  return $text;
}

/**
 * Helper function that finds the match closest to the specified offset data
 */
function _annotation_text_closest_match($haystack, $needle, $target, $length) {
  $results = array();
  $bestPos = FALSE;
  
  // get positions
  $pos = strpos($haystack, $needle);
  while ($pos !== FALSE) {
    $results[] = $pos;
    $pos = strpos($haystack, $needle, $pos + 1);
  }
  
  // find closest match
  if (count($results)) {
    $bestDiff = strlen($haystack) * 2; // extreme amount
    foreach ($results as $pos) {
      $diff = abs($target - $pos);
      if ($diff < $bestDiff) {
        $bestDiff = $diff;
        $bestPos = $pos;
      }
    }
  }
  
  return $bestPos;
}
